# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

import("../ios/fastlane/Fastfile")
import("lib/properties.rb")
import("lib/git.rb")
import("lib/download_utils.rb")

### All the configs are in this file, eventually all project specific parts will move there
import("lib/config.rb")

Options = Config::Options
Platforms = Config::Platforms
Flavors = Config::Flavors
AndroidOutputs = Config::AndroidOutputs

# Common checks before running a lane
before_all do |lane, options|
  setIfNotSet = lambda { |option, alt|
    options[option] = options.key?(option) ? options[option] : alt
  }

  # set default values
  setIfNotSet.call(Options::CLEAN, true)
  setIfNotSet.call(Options::PLATFORM, Platforms::ANDROID)
  setIfNotSet.call(Options::ANDROID_OUTPUT, AndroidOutputs::APK)
  setIfNotSet.call(Options::FLAVOR, Flavors::INTERNAL)
  setIfNotSet.call(Options::RELEASE_BUILD, false)
  setIfNotSet.call(Options::UPLOAD_TO_APPCENTER, true)
  setIfNotSet.call(Options::COVERAGE, false)
  ## downloading the iOS adhoc profile
  setIfNotSet.call(Options::DOWNLOAD_PROFILE, true)
  setIfNotSet.call(Options::UPDATE_ASSETS, false)

  version_name = gitVersionName()
  flavor = options[Options::FLAVOR]
  platform = options[Options::PLATFORM]
  offset = Config::FLAVOR_MATRIX[flavor][platform][Config::Keys::BUILD_NUMBER_OFFSET]
  build_number = gitVersionNumber().to_i + offset
  setIfNotSet.call(Options::BUILD_NUMBER, build_number)
  setIfNotSet.call(Options::VERSION_NAME, version_name)
  options[Options::ENV] = Config::ENV_DEFAULTS.to_h
  UI.success "Params:\n#{JSON.pretty_generate(options)}"
  options[Options::ENV].merge!(ENV.to_h)
  if is_ci
    UI.success "Env:\n#{JSON.pretty_generate(options[Options::ENV])}"
  end
end

# Private lanes, that we only call internally, they are nice because they have an own description
desc "Flutter build"
private_lane :flutter_build do |options|
  if options[Options::CLEAN]
    clean(options)
  end
  build_runner(options)

  platform = options[Options::PLATFORM]
  target = platform == Platforms::ANDROID ? options[Options::ANDROID_OUTPUT] : platform
  type = options[Options::RELEASE_BUILD] ? "--release" : "--debug"
  codesign = platform == Platforms::IOS ? "--no-codesign" : ""
  flavor = options[Options::FLAVOR]
  appName = Config::FLAVOR_MATRIX[flavor][platform]["name"]
  appId = Config::FLAVOR_MATRIX[flavor][platform]["id"]

  defines = {
    "GIT_TAG" => options[Options::VERSION_NAME],
    "USER_APP_ID" => appId,
    "USER_APP_NAME" => appName,
    "USER_FLAVOR" => flavor,
  }

  if platform == Platforms::IOS
    defines["USER_PROVISIONING_PROFILE"] = Config::IOS_BUILD_CONFIG[flavor]["provisioning_profile_name"]
  end
  dartDefines = defines.map { |k, v| " --dart-define=#{k}=\"#{v}\"" }.reduce("", :+)

  flutter("build #{target} #{type} #{codesign} --build-number=#{options[Options::BUILD_NUMBER]} --build-name=#{options[Options::VERSION_NAME]} #{dartDefines}")
end

desc "Prepare internal key.properties"
private_lane :android_prepare_key_properties do |options|
  UI.user_error!("No PROVISIONING_PASSWORD provided!") unless ENV.key?("PROVISIONING_PASSWORD")
  provisionigPassword = ENV["PROVISIONING_PASSWORD"]
  keyAlias = Config::ANDROID_BUILD_CONFIG[options[Options::FLAVOR]]["key_alias"]
  setProperties("../android/key.properties", {
    "storePassword" => provisionigPassword,
    "keyPassword" => provisionigPassword,
    "keyAlias" => keyAlias,
    "storeFile" => "releases.jks",
  })
end

####
#### Public lanes, can also be used via tab completion: `fastlane enable_auto_complete`
####

desc "Update strings"
lane :update_strings do |options|
  download_translations(
    api_token: "2f6281279c106f795f0c0c099eb38d8f",
    project_id: "502883",
    languages: "de,en",
    output_dir: "lib/presentation/constants/translations/",
  )
  # Need to move default language file to translations.i18n.yaml for the i18n build generator
  shell("mv lib/presentation/constants/translations/translations_en.i18n.yaml lib/presentation/constants/translations/translations.i18n.yaml")
  build_runner(options)
end

desc "Flutter build runner"
lane :build_runner do |options|
  check_config_files(options)
  if options[Options::UPDATE_ASSETS]
    update_assets(options)
  end
  mode = options[Options::WATCH] ? "watch" : "build"
  command = "pub run build_runner #{mode} --delete-conflicting-outputs"
  begin
    flutter(command)
  rescue => ex
    pub_get(options)
    flutter(command)
  end
end

desc "Checks alle the config (env, properties, etc) if they are correctly set"
lane :check_config_files do |options|
  askAndSetProperties("../.env.dev",
                      {
    "SEARCH_API_URL_DEBUG" => "SEARCH_API_BASE_URL",
    "SEARCH_API_SECRET_DEBUG" => "SEARCH_API_SECRET_KEY",
    "IMAGE_FETCHER_URL_DEBUG" => "IMAGE_FETCHER_URL",
    "INSTABUG_TOKEN_DEBUG" => "INSTABUG_TOKEN",
    "AMPLITUDE_API_KEY_DEBUG" => "AMPLITUDE_API_KEY",
    "APPSFLYER_DEV_KEY" => "APPSFLYER_DEV_KEY",
    "APP_STORE_NUMERICAL_ID_DEBUG" => "APP_STORE_NUMERICAL_ID",
    "AI_ASSETS_URL" => "AI_ASSETS_URL",
  }, Config::ENV_DEFAULTS)

  askAndSetProperties("../.env.prod",
                      {
    "SEARCH_API_URL_PRODUCTION" => "SEARCH_API_BASE_URL",
    "SEARCH_API_SECRET_PRODUCTION" => "SEARCH_API_SECRET_KEY",
    "IMAGE_FETCHER_URL_PRODUCTION" => "IMAGE_FETCHER_URL",
    "INSTABUG_TOKEN_PRODUCTION" => "INSTABUG_TOKEN",
    "AMPLITUDE_API_KEY_PRODUCTION" => "AMPLITUDE_API_KEY",
    "APPSFLYER_DEV_KEY" => "APPSFLYER_DEV_KEY",
    "APP_STORE_NUMERICAL_ID_PRODUCTION" => "APP_STORE_NUMERICAL_ID",
    "AI_ASSETS_URL" => "AI_ASSETS_URL",
  }, Config::ENV_DEFAULTS)

  if options[Options::FLAVOR] != Flavors::INTERNAL && options[Options::RELEASE_BUILD]
    askAndSetProperties("../android/custom.properties", { "INSTABUG_TOKEN_PRODUCTION" => "INSTABUG_TOKEN" }, Config::ENV_DEFAULTS)
  else
    askAndSetProperties("../android/custom.properties", { "INSTABUG_TOKEN_DEBUG" => "INSTABUG_TOKEN" }, Config::ENV_DEFAULTS)
  end
end

desc "Flutter pub get"
lane :pub_get do |options|
  flutter("pub get")
end

desc "Watch changes for rerunning the build_runner"
lane :watch do |options|
  options[Options::WATCH] = true
  build_runner(options)
end

desc "Flutter clean"
lane :clean do |options|
  flutter("clean")
end

desc "Sanity checks (options: coverage:[true/FALSE])"
lane :check do |options|
  pub_get(options)
  if Dir.glob("../**/env.g.dart").empty?
    build_runner(options)
  end
  flutter("analyze lib test")
  if is_ci
    flutter("format ./ --set-exit-if-changed")
  else
    flutter("format ./")
  end
  if options[Options::COVERAGE]
    # Creates a fake test that imports all files so that lcov calculates the correct coverage
    shell('find lib ! -name "*.freezed.dart" ! -name "*.config.dart" ! -name "*.g.dart" ! -name "generated_plugin_registrant.dart"  -name *.dart  | sed \'s/lib\///\' | sed  \'s/.*/import "package:xayn_discovery_app\/&";/\' > test/all_imports_test.dart')
    shell("cat test/test_stub.dart >> test/all_imports_test.dart")
    flutter("test --coverage")
    lcov_ignore_rules = shell("cat lcov_ignore | grep -v \\# | tr '\n' ' '")
    shell("mv coverage/lcov.info coverage/original_lcov.info")
    shell("lcov --remove coverage/original_lcov.info #{lcov_ignore_rules} -o coverage/lcov.info")
    shell("genhtml coverage/lcov.info -o coverage/html")
  else
    flutter("test")
  end
end

desc "Build and publish (i.e fastlane publish platform:ios release_build:true flavor:beta)"
lane :publish do |options|
  platform = options[Options::PLATFORM]
  flavor = options[Options::FLAVOR]
  config = Config::FLAVOR_MATRIX[flavor][platform]
  appcenter_target = config["appcenter_target"]
  appcenter_token = config["appcenter_token"]
  appcenter_buildfile = config["appcenter_buildfile"]

  if platform == Platforms::ANDROID
    android_prepare_key_properties(options)
  end
  flutter_build(options)
  if platform == Platforms::IOS
    Dir.chdir("../ios/fastlane") do
      ios_create_ipa(options)
    end
  end
  if options[Options::UPLOAD_TO_APPCENTER]
    UI.user_error!("No $#{appcenter_token} provided!") unless ENV.key?(appcenter_token)
    uploadToAppCenter(
      ENV[appcenter_token],
      appcenter_target,
      appcenter_buildfile,
      options[Options::VERSION_NAME]
    )
  end
end

desc "Update the assets folder based on the Assets Manifest from xayn_discovery_engine"
lane :update_assets do |options|
  manifestPath = File.join(pathFromDependency("xayn_discovery_engine"), "assets", "asset_manifest.json")
  manifestPath["file://"] = ""
  raise "No manifest file at #{manifestPath}" unless File.file?(manifestPath)
  UI.user_error!("No AI_ASSETS_URL provided!") unless options[Options::ENV].key?("AI_ASSETS_URL")
  downloadAssetsFromManifest(manifestPath, options[Options::ENV]["AI_ASSETS_URL"], File.join("..", "assets", "ai"))
end

# Private helper methods
def flutter(args)
  Dir.chdir("..") do
    sh "flutter #{args}"
  end
end

def shell(args)
  Dir.chdir("..") do
    sh(args)
  end
end

def uploadToAppCenter(token, appName, path, version)
  changelog = gitChangeLog(version)
  appcenter_upload(
    api_token: token,
    owner_name: Config::APPCENTER_OWNER_NAME,
    owner_type: Config::APPCENTER_OWNER_TYPE,
    app_name: appName,
    file: path,
    release_notes: changelog,
    destinations: Config::APPCENTER_DEFAULT_TARGET,
    notify_testers: true,
  )
end

def pathFromDependency(dependency)
  properties = loadProperties("../.packages", ":")
  path = properties[dependency]
  raise "Can not find #{dependency} in ../.packages " if (path == nil)
  return path
end

def downloadAssetsFromManifest(manifestPath, assetUrl, assetPath)
  file = File.read(manifestPath)
  data_hash = JSON.parse(file)
  data_hash["assets"].each { |a|
    suffix = a["url_suffix"]
    checksum = a["checksum"]
    downloadOnlyWhenNotMatchingSha2(assetUrl, suffix, assetPath, checksum)
  }
end
